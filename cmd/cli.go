package cmd

import (
	"errors"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/gopacket/pcap"
	"github.com/spf13/cobra"

	"github.com/cochaviz/gomon/internal"
)

const asciiBanner = `
     _______    ______   ___ __ __   ______   ___   __
    /______/\  /_____/\ /__//_//_/\ /_____/\ /__/\ /__/\
    \::::__\/__\:::_ \ \\::\| \| \ \\:::_ \ \\::\_\\  \ \
     \:\ /____/\\:\ \ \ \\:.      \ \\:\ \ \ \\:.  -\  \ \
      \:\\_  _\/ \:\ \ \ \\:.\-/\  \ \\:\ \ \ \\:. _    \ \
       \:\_\ \ \  \:\_\ \ \\. \  \  \ \\:\_\ \ \\. \ -\  \ \
        \_____\/   \_____\/ \__\/ \__\/ \_____\/ \__\/ \__\/`

const (
	defaultWindowSizeS        = 30
	defaultPacketRateThresh   = 5.0
	defaultUniqueIPRateThresh = 10.0
	defaultLogLevel           = "info"
)

var (
	packetRateThreshold   = defaultPacketRateThresh
	uniqueIPRateThreshold = defaultUniqueIPRateThresh
	logLevelStr           = defaultLogLevel
	windowSizeSeconds     = defaultWindowSizeS
	showIdle              bool
	c2IP                  string
	sampleID              string
	ignoreDestIPs         []string
	eveLogPath            string
	savePacketsCount      int
)

func init() {
	RootCmd.Flags().Float64Var(
		&packetRateThreshold,
		"packet-threshold",
		defaultPacketRateThresh,
		"Packet rate threshold per window before marking traffic as suspicious.",
	)
	RootCmd.Flags().Float64Var(
		&uniqueIPRateThreshold,
		"ip-threshold",
		defaultUniqueIPRateThresh,
		"Destination IP diversity threshold per window before flagging a scan.",
	)
	RootCmd.Flags().StringVar(
		&logLevelStr,
		"log-level",
		logLevelStr,
		"Logging level (debug, info, warn, error).",
	)
	RootCmd.Flags().IntVar(
		&windowSizeSeconds,
		"window",
		defaultWindowSizeS,
		"Analysis window size in seconds.",
	)
	RootCmd.Flags().StringVar(
		&c2IP,
		"c2-ip",
		"",
		"Command-and-control IP address associated with the traffic (optional).",
	)
	RootCmd.Flags().StringVar(
		&sampleID,
		"sample-id",
		"",
		"Identifier used to correlate analysis results to a specific sample (optional).",
	)
	RootCmd.Flags().StringSliceVar(
		&ignoreDestIPs,
		"ignore-dst",
		nil,
		"Destination IP addresses to skip when computing metrics (repeatable).",
	)
	RootCmd.Flags().StringVar(
		&eveLogPath,
		"eve-log-path",
		"",
		"Optional file path for Eve JSON output (stdout if omitted).",
	)
	RootCmd.Flags().BoolVar(
		&showIdle,
		"show-idle",
		false,
		"Emit idle window events (disabled by default).",
	)
	RootCmd.Flags().IntVar(
		&savePacketsCount,
		"save-packets",
		0,
		"Number of most recent packets per host to retain for capture artifacts when an attack is detected.",
	)
}

var RootCmd = &cobra.Command{
	Use:   "gomon <input> <src_ip>",
	Short: "Detect interesting network events for sandboxed bots.",
	Long: `gomon ingests live traffic or PCAP captures generated by sandboxed bots and
identifies time windows that exceed packet-rate or destination-IP thresholds. The tool logs
structured alerts that highlight scans or bursts of suspicious activity.`,
	Example: "gomon sample.pcap 10.0.0.5 --window 15 --packet-threshold 20 --log-level info --c2-ip 203.0.113.4 --ignore-dst 192.0.2.10 --sample-id malware-sample-42",
	Args:    cobra.ExactArgs(2),
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		cmd.Println(asciiBanner)
		cmd.Println()
	},
	RunE: executeAnalysis,
}

func executeAnalysis(cmd *cobra.Command, args []string) error {
	input := args[0]
	srcIP := args[1]

	if eveLogPath != "" {
		if err := ensureOutputDir(filepath.Dir(eveLogPath)); err != nil {
			return err
		}
	}

	if packetRateThreshold <= 0 {
		return fmt.Errorf("packet-threshold must be greater than 0, received %f", packetRateThreshold)
	}
	if uniqueIPRateThreshold < 0 {
		return fmt.Errorf("ip-threshold must be non-negative, received %f", uniqueIPRateThreshold)
	}
	if windowSizeSeconds <= 0 {
		return fmt.Errorf("window must be greater than 0, received %d", windowSizeSeconds)
	}

	level, err := parseLogLevel(logLevelStr)
	if err != nil {
		return err
	}

	handle, err := resolveHandle(input)
	if err != nil {
		return err
	}

	config := internal.NewAnalysisConfiguration(
		srcIP,
		c2IP,
		ignoreDestIPs,
		showIdle,
		time.Duration(windowSizeSeconds)*time.Second,
		eveLogPath,
		packetRateThreshold,
		uniqueIPRateThreshold,
		level,
		sampleID,
		savePacketsCount,
	)
	defer func() {
		if err := config.Close(); err != nil {
			cmd.PrintErrf("warning: unable to close log file: %v\n", err)
		}
	}()

	if err := internal.CaptureLoop(handle, config); err != nil {
		return fmt.Errorf("capture loop failed: %w", err)
	}

	if eveLogPath != "" {
		cmd.Printf("Analysis complete. Eve log: %s\n", filepath.Clean(eveLogPath))
	} else {
		cmd.Printf("Analysis complete.")
	}
	return nil
}

func parseLogLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error", "err":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("unsupported log-level %q (expected debug, info, warn, error)", level)
	}
}

func resolveHandle(input string) (*pcap.Handle, error) {
	isPCAP := strings.HasSuffix(strings.ToLower(input), ".pcap")
	if isPCAP {
		return HandleFromFile(input)
	}

	info, err := os.Stat(input)
	if err == nil {
		if info.IsDir() {
			return nil, fmt.Errorf("input %q is a directory; expected file or interface", input)
		}
		return HandleFromFile(input)
	}

	if !errors.Is(err, fs.ErrNotExist) {
		return nil, fmt.Errorf("unable to inspect %q: %w", input, err)
	}

	return HandleFromInterface(input)
}

func ensureOutputDir(dirPath string) error {
	if dirPath == "" {
		return nil
	}

	info, err := os.Stat(dirPath)
	if err == nil {
		if !info.IsDir() {
			return fmt.Errorf("output path %q is not a directory", dirPath)
		}
		return nil
	}

	if errors.Is(err, fs.ErrNotExist) {
		// Create the directory tree so subsequent steps can use it.
		if mkErr := os.MkdirAll(dirPath, 0o755); mkErr != nil {
			return fmt.Errorf("unable to create output directory %q: %w", dirPath, mkErr)
		}
		return nil
	}

	return fmt.Errorf("unable to access output directory %q: %w", dirPath, err)
}
