package cmd

import (
	"errors"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/gopacket/pcap"
	"github.com/spf13/cobra"

	"cochaviz/net_analysis/internal"
)

const (
	defaultWindowSizeS        = 30
	defaultPacketRateThresh   = 5.0
	defaultUniqueIPRateThresh = 10.0
)

var (
	packetRateThreshold   = defaultPacketRateThresh
	uniqueIPRateThreshold = defaultUniqueIPRateThresh
	logLevelStr           = "debug"
	windowSizeSeconds     = defaultWindowSizeS
	c2IP                  string
	sampleID              string
	ignoreDestIPs         []string
	outputFile            string
)

func init() {
	RootCmd.Flags().Float64Var(
		&packetRateThreshold,
		"packet-threshold",
		defaultPacketRateThresh,
		"Packet rate threshold per window before marking traffic as suspicious.",
	)
	RootCmd.Flags().Float64Var(
		&uniqueIPRateThreshold,
		"ip-threshold",
		defaultUniqueIPRateThresh,
		"Destination IP diversity threshold per window before flagging a scan.",
	)
	RootCmd.Flags().StringVar(
		&logLevelStr,
		"log-level",
		logLevelStr,
		"Logging level (debug, info, warn, error).",
	)
	RootCmd.Flags().IntVar(
		&windowSizeSeconds,
		"window",
		defaultWindowSizeS,
		"Analysis window size in seconds.",
	)
	RootCmd.Flags().StringVar(
		&c2IP,
		"c2-ip",
		"",
		"Command-and-control IP address associated with the traffic (optional).",
	)
	RootCmd.Flags().StringVar(
		&sampleID,
		"sample-id",
		"",
		"Identifier used to correlate analysis results to a specific sample (optional).",
	)
	RootCmd.Flags().StringSliceVar(
		&ignoreDestIPs,
		"ignore-dst",
		nil,
		"Destination IP addresses to skip when computing metrics (repeatable).",
	)
	RootCmd.Flags().StringVar(
		&outputFile,
		"output",
		"",
		"Optional file path for JSON log output.",
	)
}

var RootCmd = &cobra.Command{
	Use:   "net_analysis <input> <src_ip>",
	Short: "Detect interesting network events for sandboxed bots.",
	Long: `net_analysis ingests live traffic or PCAP captures generated by sandboxed bots and
identifies time windows that exceed packet-rate or destination-IP thresholds. The tool logs
structured alerts that highlight scans or bursts of suspicious activity.`,
	Example: "net_analysis sample.pcap 10.0.0.5 --window 15 --packet-threshold 20 --log-level info --c2-ip 203.0.113.4 --ignore-dst 192.0.2.10 --sample-id malware-sample-42",
	Args:    cobra.ExactArgs(2),
	RunE:    executeAnalysis,
}

func executeAnalysis(cmd *cobra.Command, args []string) error {
	input := args[0]
	srcIP := args[1]

	if err := ensureOutputDir(path.Dir(outputFile)); err != nil {
		return err
	}

	if packetRateThreshold <= 0 {
		return fmt.Errorf("packet-threshold must be greater than 0, received %f", packetRateThreshold)
	}
	if uniqueIPRateThreshold < 0 {
		return fmt.Errorf("ip-threshold must be non-negative, received %f", uniqueIPRateThreshold)
	}
	if windowSizeSeconds <= 0 {
		return fmt.Errorf("window must be greater than 0, received %d", windowSizeSeconds)
	}

	level, err := parseLogLevel(logLevelStr)
	if err != nil {
		return err
	}

	handle, err := resolveHandle(input)
	if err != nil {
		return err
	}

	config := internal.NewAnalysisConfiguration(
		srcIP,
		c2IP,
		ignoreDestIPs,
		time.Duration(windowSizeSeconds)*time.Second,
		outputFile,
		packetRateThreshold,
		uniqueIPRateThreshold,
		level,
		sampleID,
	)
	defer func() {
		if err := config.Close(); err != nil {
			cmd.PrintErrf("warning: unable to close log file: %v\n", err)
		}
	}()

	if err := internal.CaptureLoop(handle, config); err != nil {
		return fmt.Errorf("capture loop failed: %w", err)
	}

	if outputFile != "" {
		cmd.Printf("Analysis complete. Output file: %s\n", filepath.Clean(outputFile))
	} else {
		cmd.Printf("Analysis complete.")
	}
	return nil
}

func parseLogLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error", "err":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("unsupported log-level %q (expected debug, info, warn, error)", level)
	}
}

func resolveHandle(input string) (*pcap.Handle, error) {
	isPCAP := strings.HasSuffix(strings.ToLower(input), ".pcap")
	if isPCAP {
		return HandleFromFile(input)
	}

	info, err := os.Stat(input)
	if err == nil {
		if info.IsDir() {
			return nil, fmt.Errorf("input %q is a directory; expected file or interface", input)
		}
		return HandleFromFile(input)
	}

	if !errors.Is(err, fs.ErrNotExist) {
		return nil, fmt.Errorf("unable to inspect %q: %w", input, err)
	}

	return HandleFromInterface(input)
}

func ensureOutputDir(path string) error {
	if path == "" {
		return nil
	}

	info, err := os.Stat(path)
	if err == nil {
		if !info.IsDir() {
			return fmt.Errorf("output path %q is not a directory", path)
		}
		return nil
	}

	if errors.Is(err, fs.ErrNotExist) {
		// Create the directory tree so subsequent steps can use it.
		if mkErr := os.MkdirAll(path, 0o755); mkErr != nil {
			return fmt.Errorf("unable to create output directory %q: %w", path, mkErr)
		}
		return nil
	}

	return fmt.Errorf("unable to access output directory %q: %w", path, err)
}
