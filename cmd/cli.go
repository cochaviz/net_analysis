package cmd

import (
	"errors"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/gopacket/pcap"
	"github.com/spf13/cobra"

	"github.com/cochaviz/gomon/internal"
)

const asciiBanner = `
     _______    ______   ___ __ __   ______   ___   __
    /______/\  /_____/\ /__//_//_/\ /_____/\ /__/\ /__/\
    \::::__\/__\:::_ \ \\::\| \| \ \\:::_ \ \\::\_\\  \ \
     \:\ /____/\\:\ \ \ \\:.      \ \\:\ \ \ \\:.  -\  \ \
      \:\\_  _\/ \:\ \ \ \\:.\-/\  \ \\:\ \ \ \\:. _    \ \
       \:\_\ \ \  \:\_\ \ \\. \  \  \ \\:\_\ \ \\. \ -\  \ \
        \_____\/   \_____\/ \__\/ \__\/ \_____\/ \__\/ \__\/`

const (
	defaultWindowSizeS        = 30
	defaultPacketRateThresh   = 5.0
	defaultUniqueIPRateThresh = 10.0
	defaultLogLevel           = "info"
)

var (
	packetRateThreshold   = defaultPacketRateThresh
	uniqueIPRateThreshold = defaultUniqueIPRateThresh
	logLevelStr           = defaultLogLevel
	windowSizeSeconds     = defaultWindowSizeS
	captureDirPath        string
	showIdle              bool
	c2IP                  string
	sampleID              string
	ignoreDestIPs         []string
	eveLogPath            string
	savePacketsCount      int
)

func init() {
	RootCmd.Flags().Float64Var(
		&packetRateThreshold,
		"packet-threshold",
		defaultPacketRateThresh,
		"Packet rate threshold per window before marking traffic as suspicious.",
	)
	RootCmd.Flags().Float64Var(
		&uniqueIPRateThreshold,
		"ip-threshold",
		defaultUniqueIPRateThresh,
		"Destination IP diversity threshold per window before flagging a scan.",
	)
	RootCmd.Flags().StringVar(
		&logLevelStr,
		"log-level",
		logLevelStr,
		"Logging level (debug, info, warn, error).",
	)
	RootCmd.Flags().IntVar(
		&windowSizeSeconds,
		"window",
		defaultWindowSizeS,
		"Analysis window size in seconds.",
	)
	RootCmd.Flags().StringVar(
		&c2IP,
		"c2-ip",
		"",
		"Command-and-control IP address associated with the traffic (optional).",
	)
	RootCmd.Flags().StringVar(
		&sampleID,
		"sample-id",
		"",
		"Identifier used to correlate analysis results to a specific sample (optional).",
	)
	RootCmd.Flags().StringSliceVar(
		&ignoreDestIPs,
		"ignore-dst",
		nil,
		"Destination IP addresses to skip when computing metrics (repeatable).",
	)
	RootCmd.Flags().StringVar(
		&eveLogPath,
		"eve-log-path",
		"",
		"Optional file path for Eve JSON output (stdout if omitted).",
	)
	RootCmd.Flags().BoolVar(
		&showIdle,
		"show-idle",
		false,
		"Emit idle window events (disabled by default).",
	)
	RootCmd.Flags().StringVar(
		&captureDirPath,
		"capture-dir",
		"",
		"Directory for packet capture artifacts (default: ./captures).",
	)
	RootCmd.Flags().IntVar(
		&savePacketsCount,
		"save-packets",
		0,
		"Number of most recent packets per host to retain for capture artifacts when an attack is detected.",
	)
}

var RootCmd = &cobra.Command{
	Use:   "gomon <input> <src_ip>",
	Short: "Detect interesting network events for sandboxed bots.",
	Long: `gomon ingests live traffic or PCAP captures generated by sandboxed bots and
identifies time windows that exceed packet-rate or destination-IP thresholds. The tool logs
structured alerts that highlight scans or bursts of suspicious activity.`,
	Example: "gomon sample.pcap 10.0.0.5 --window 15 --packet-threshold 20 --log-level info --c2-ip 203.0.113.4 --ignore-dst 192.0.2.10 --sample-id malware-sample-42",
	Args:    cobra.ExactArgs(2),
	PersistentPreRun: func(cmd *cobra.Command, args []string) {
		cmd.Println(asciiBanner)
		cmd.Println()
		cmd.Print(renderRuntimeConfiguration(args))
	},
	RunE: executeAnalysis,
}

func executeAnalysis(cmd *cobra.Command, args []string) error {
	input := args[0]
	srcIP := args[1]

	if eveLogPath != "" {
		if err := ensureOutputDir(filepath.Dir(eveLogPath)); err != nil {
			return err
		}
	}

	if packetRateThreshold <= 0 {
		return fmt.Errorf("packet-threshold must be greater than 0, received %f", packetRateThreshold)
	}
	if uniqueIPRateThreshold < 0 {
		return fmt.Errorf("ip-threshold must be non-negative, received %f", uniqueIPRateThreshold)
	}
	if windowSizeSeconds <= 0 {
		return fmt.Errorf("window must be greater than 0, received %d", windowSizeSeconds)
	}
	if captureDirPath == "" {
		captureDirPath = filepath.Join(".", "captures")
	} else if err := ensureOutputDir(captureDirPath); err != nil {
		return err
	}

	level, err := parseLogLevel(logLevelStr)
	if err != nil {
		return err
	}

	handle, err := resolveHandle(input)
	if err != nil {
		return err
	}

	config := internal.NewAnalysisConfiguration(
		srcIP,
		c2IP,
		ignoreDestIPs,
		showIdle,
		time.Duration(windowSizeSeconds)*time.Second,
		eveLogPath,
		packetRateThreshold,
		uniqueIPRateThreshold,
		level,
		sampleID,
		savePacketsCount,
		captureDirPath,
		nil,
	)
	defer func() {
		if err := config.Close(); err != nil {
			cmd.PrintErrf("warning: unable to close log file: %v\n", err)
		}
	}()

	if err := internal.CaptureLoop(handle, config); err != nil {
		return fmt.Errorf("capture loop failed: %w", err)
	}

	summary := config.Summary()

	if eveLogPath != "" {
		cmd.Printf("Analysis complete. Eve log: %s\n", filepath.Clean(eveLogPath))
	} else {
		cmd.Println("Analysis complete. Eve log: stdout")
	}
	cmd.Printf(
		"Summary: %d attack alert(s), %d scan alert(s), %d idle window(s), %d capture(s) saved\n",
		summary.AttackEvents,
		summary.ScanEvents,
		summary.IdleEvents,
		summary.SavedCaptures,
	)
	return nil
}

func parseLogLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error", "err":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("unsupported log-level %q (expected debug, info, warn, error)", level)
	}
}

func resolveHandle(input string) (*pcap.Handle, error) {
	isPCAP := strings.HasSuffix(strings.ToLower(input), ".pcap")
	if isPCAP {
		return HandleFromFile(input)
	}

	info, err := os.Stat(input)
	if err == nil {
		if info.IsDir() {
			return nil, fmt.Errorf("input %q is a directory; expected file or interface", input)
		}
		return HandleFromFile(input)
	}

	if !errors.Is(err, fs.ErrNotExist) {
		return nil, fmt.Errorf("unable to inspect %q: %w", input, err)
	}

	return HandleFromInterface(input)
}

func ensureOutputDir(dirPath string) error {
	if dirPath == "" {
		return nil
	}

	info, err := os.Stat(dirPath)
	if err == nil {
		if !info.IsDir() {
			return fmt.Errorf("output path %q is not a directory", dirPath)
		}
		return nil
	}

	if errors.Is(err, fs.ErrNotExist) {
		// Create the directory tree so subsequent steps can use it.
		if mkErr := os.MkdirAll(dirPath, 0o755); mkErr != nil {
			return fmt.Errorf("unable to create output directory %q: %w", dirPath, mkErr)
		}
		return nil
	}

	return fmt.Errorf("unable to access output directory %q: %w", dirPath, err)
}

func renderRuntimeConfiguration(args []string) string {
	const placeholder = "<unset>"

	var inputArg, srcArg string
	if len(args) > 0 {
		inputArg = args[0]
	} else {
		inputArg = placeholder
	}
	if len(args) > 1 {
		srcArg = args[1]
	} else {
		srcArg = placeholder
	}

	window := (time.Duration(windowSizeSeconds) * time.Second).String()

	captureDir := captureDirPath
	if captureDir == "" {
		captureDir = filepath.Join(".", "captures")
	}
	captureDir = filepath.Clean(captureDir)

	eveDestination := "stdout"
	if eveLogPath != "" {
		eveDestination = filepath.Clean(eveLogPath)
	}

	var ignoredDest string
	switch len(ignoreDestIPs) {
	case 0:
		ignoredDest = "<none>"
	default:
		ignoredDest = strings.Join(ignoreDestIPs, ", ")
	}

	c2Display := c2IP
	if c2Display == "" {
		c2Display = "<none>"
	}
	sampleDisplay := sampleID
	if sampleDisplay == "" {
		sampleDisplay = "<none>"
	}

	var b strings.Builder
	b.WriteString("Configuration:\n")
	fmt.Fprintf(&b, "  input: %s\n", inputArg)
	fmt.Fprintf(&b, "  source-ip: %s\n", srcArg)
	fmt.Fprintf(&b, "  window: %s\n", window)
	fmt.Fprintf(&b, "  packet-threshold: %.2f\n", packetRateThreshold)
	fmt.Fprintf(&b, "  ip-threshold: %.2f\n", uniqueIPRateThreshold)
	fmt.Fprintf(&b, "  log-level: %s\n", logLevelStr)
	fmt.Fprintf(&b, "  show-idle: %t\n", showIdle)
	fmt.Fprintf(&b, "  c2-ip: %s\n", c2Display)
	fmt.Fprintf(&b, "  sample-id: %s\n", sampleDisplay)
	fmt.Fprintf(&b, "  ignore-dst: %s\n", ignoredDest)
	fmt.Fprintf(&b, "  save-packets: %d\n", savePacketsCount)
	fmt.Fprintf(&b, "  capture-dir: %s\n", captureDir)
	fmt.Fprintf(&b, "  eve-log-path: %s\n", eveDestination)

	return b.String()
}
